{"pageProps":{"title":"Immutability (2) - Immutable.js, pros and cons","date":"Oct 14, 2021","tag":["JavaScript","Library","Immutability"],"excerpt":"How Immutable.js works with persistent data structures, and its pros and cons...","content":"\nWe need to keep original data to avoid side effects. If it is primitive data type, there is nothing to care about. If it is an object, we normally copy and manipulate it to keep the original data immutable. In this way, we might get problem when we deal with large data.\n\nTo keep the original object, we need to deep copy it. It means we need to allocate the space in memory for the entire object, even all of the stuff that didn't change. The both time and space complexity will be so bad. The code runs slow.\n\nThere are many of libraries to solve this problem, and I picked Immutable.js. It is a library to support immutable data structure, supported by Facebook. I would explain how it deal with immutability efficiently, and its disadvantages.\n\n## How Immutable.js works\n\n```js\nconst { Map } = require(\"immutable\");\n\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = map1.set(\"b\", 50);\n\nconsole.log(map1.get(\"b\")); // 2\nconsole.log(map2.get(\"b\")); // 50\nconsole.log(map1 == map2); // false\n```\n\nI made map1 object, then executed map1.set to change a value with key \"b\". It did not change a value of key \"b\" in map1, but returned new object, map2, with new value of key \"b\".\n\nIt looks like copying whole object and change one value, but worked totally different inside. Map1 and map2 objects are sharing values just except the changed value to minimize consuming memory. It is implemented by persistent data structures.\n\n---\n\n```js\nconst { fromJS } = require(\"immutable\");\n\nconst nested = fromJS({ a: { b: { c: [3, 4, 5] } } });\nconst nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\n\nconsole.log(nested);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }\nconsole.log(nested2);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\nconsole.log(nested == nested2); // false\n```\n\nThe collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON.\n\n## Persistent data structures\n\nIn computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure.\n\nIt is commonly used in functional programming to enforce immutability. Many of languages with functional programming paradigm has implementations of persistent data structures, but JavaScript does not. Immutable.js is a library to support this to JavaScript.\n\nIt is optimized with trie data structure. I will provide an example below to understand easily.\n\n---\n\n```js\nconst data = {\n  to: 7,\n  tea: 3,\n  ted: 4,\n  ten: 12,\n  A: 15,\n  i: 11,\n  in: 5,\n  inn: 9,\n};\n```\n\n<img src=\"https://waynechoidev.github.io/expired-waynechi.dev/images/posts/trie_original.png\">\n\nI made an JS object, and created a trie with same keys and values. A trie is a type of tree where the leaves hold the values, and the paths from the root to the values represent the keys. So I can access a value by traversing the tree to get one letter at a time.\n\n---\n\n<img src=\"https://waynechoidev.github.io/expired-waynechi.dev/images/posts/trie_path.png\">\n\nFor example, if I want to get a value with a key, 'ted', I can start from root, and follow the paths represented 't', 'e', and 'd'. I arrived at a node that contains 4.\n\n---\n\n<img src=\"https://waynechoidev.github.io/expired-waynechi.dev/images/posts/trie_changed.png\">\n\nI changed the value at the key 'ted' from 4 to 8. Other nodes are still used. With this structures, only few nodes are recreated when we change a single item,\n\n## Disadvantages of Immutable.js\n\nAll the data structure implemented with Immutable.js are custom object. It means it is not JSON format. JSON is widely used format to communicate. If we use custom objects like data structures of Immutable.js, we need to convert them to JSON format first. It consumes time and memory, and it is a huge consumption when data is large.\n\nIn addition, we cannot use methods of Object and Array object in Immutable.js data structures. It raises the running curve, and dependency to a specific library.\n\n---\n\n- [Immutability (1) - Object.freeze() doesn't always freeze](https://waynechoidev.github.io/expired-waynechi.dev/immutability_object_freeze_doesnt_always_freeze)\n- **Immutability (2) - Immutable.js, pros and cons**\n\n## References\n\n- [Anjana Vakil: Immutable data structures for functional JS | JSConf EU](https://youtu.be/Wo0qiGPSV-s)\n- [Wikipedia](https://en.wikipedia.org/wiki/Persistent_data_structure#Trees)\n- [Immutable.js](https://immutable-js.com/)\n- [How Immutable Data Structures (E.g. Immutable.js) are Optimized](https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56)\n- 함수형 자바스크립트 프로그래밍 - 유인동\n"},"__N_SSG":true}