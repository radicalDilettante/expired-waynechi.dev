{"pageProps":{"frontMatter":{"title":"NeoQuery, the simplified jQuery","date":"Sep 1, 2021","tag":["JS Library","JavaScript"],"excerpt":"I made a DOM manipulation library, and I was highly motivated from jQuery... "},"content":"\r\njQuery, which used to be a market-dominant library, is getting less attention in 2021. It is not an attractive option for new projects anymore, but legacy. Most browsers support web standards, and JavaScript improved a lot with ES6 update. We got fancy api like querySelectorAll() instead of getElementById(), and it is as convenient as jQuery methods.\r\n\r\nIn addition, jQuery is too heavy. In modern JS ecosystem, modularized library is recommend to use. jQuery, however, does have too many features. It helps Dom manipulation, CSS styling, event handling, animation, and ajax. They could be covered with modern JavaScript, or sometimes other modularized library like Axios.\r\n\r\nBut I believe jQuery syntax still works well. Especially its way to manipulate DOM with chaining method is still attractive. So I made a library, which is highly motivated from jQuery, and has similar methods and syntax, to manipulate DOM. It is [NeoQuery.](https://github.com/waynethebb/neoquery)\r\n\r\n---\r\n\r\n## Fluent Interface\r\n\r\nA fluent interface is normally implemented by using method chaining to implement method cascading. jQuery is one of the most representative examples of use.\r\n\r\n```javascript\r\n//jQuery example\r\n$(\"#textNode\").css(\"color\", \"red\").appendTo(\"#someDiv\");\r\n```\r\n\r\nIt is implemented by having each method return the object to which it is attached, often referred to as \"this\". Stated more abstractly, a fluent interface relays the instruction context of a subsequent call in method chaining, where generally the context is\r\n\r\n- Defined through the return value of a called method\r\n- Self-referential, where the new context is equivalent to the last context\r\n- Terminated through the return of a void context\r\n\r\n```javascript\r\nClass Person{\r\n    constructor(){\r\n        this.name;\r\n        this.age;\r\n    }\r\n\r\n    setName(name) {\r\n        this.name = name\r\n        return this\r\n    }\r\n\r\n    setAge(age) {\r\n        this.age = age\r\n        return this\r\n    }\r\n\r\n    sayHi() {\r\n        console.log(`Hi. I am ${this.name}, ${age} years old.`)\r\n        return this\r\n    }\r\n}\r\n\r\nnew Person().setName(\"Wayne\").setAge(\"30\").sayHi();\r\n//\"Hi. I am Wayne, 30 years old.\"\r\n```\r\n\r\nI tried to implement chaining method with similar syntax as jQuery. I didn't export class, but export $() function which create instance of the fluent interface class, and return method of the class.\r\n\r\n```javascript\r\nexport default function $(query) {\r\n  return neoQuery.selectQuery(query);\r\n}\r\n\r\nclass NeoQuery {\r\n  constructor() {\r\n    this.element;\r\n  }\r\n\r\n  selectQuery(query) {\r\n    const newElement = document.querySelectorAll(query);\r\n    this.element = newElement;\r\n    return this;\r\n  }\r\n\r\n  addClass() {\r\n    ...\r\n    this.element = ...\r\n    return this;\r\n  }\r\n\r\n  appendTo(query) {\r\n    ...\r\n    this.element = ...\r\n    return this;\r\n  }\r\n  ...\r\n}\r\n\r\n$(\"#textNode\").addClass(\"myClass\").appendTo(\"#someDiv\");\r\n```\r\n\r\n---\r\n\r\n## $()\r\n\r\nThe function, $(), is to create new instance, and start chaining methods. It has three features.\r\n\r\n```javascript\r\n$(callback);\r\n// Binds a function to be executed when the DOM has finished loading.\r\n// It doesn't chain methods.\r\n// ex) $(()=>{console.log(\"ready\")})\r\n\r\n$(selector);\r\n// Selects DOM elements with a CSS selector\r\n// ex) $( \"div.foo\" ).---\r\n\r\n$(html);\r\n//Creates DOM elements from the provided string of raw HTML.\r\n// ex) $(\"<div>test</div>\").---\r\n```\r\n\r\n---\r\n\r\n## Methods\r\n\r\nI made all methods (except $()), have only one feature. It is to avoid unnecessary logic to categorize arguments for running different feature in one methods, and has more intuitive interface.\r\n\r\n```javascript\r\n// jQuery\r\nattr(attributeName); // Get the value of attributes\r\nattr(attributeName, value); // Set attributes\r\n\r\n// neoQuery\r\nattr(attributeName); // Get the value of an attributes\r\naddAttr(attributeName, value); // Set attributes\r\n```\r\n\r\n---\r\n\r\n## Other features\r\n\r\nI didn't create ajax and animation features, and minimize styling and event handling features. I intended to make this library as light as possible.\r\n\r\n### Styling\r\n\r\n- addCss(propertyName, value)\r\n- removeCss(propertyName)\r\n- show()\r\n- hide()\r\n\r\nI believe in-line styling need to be rejected, so I did not implement other styling methods. Unlike jQuery, those method can get only one property name as an argument.(\"css()\" the jQuery method can get object for css properties)\r\n\r\n\"show()\" and \"hide()\" methods was only exception. I think those methods are more like DOM control, and it does not conflict against other style properties.\r\n\r\n### Event\r\n\r\n- on(event, callback)\r\n- one(event, callback)\r\n- off(event, callback)\r\n\r\nI did not make other features to create event listener, but methods we can use with the browser event types.\r\n\r\n---\r\n\r\n## References\r\n\r\n- [\"jQuery: The write less, do more, JavaScript library\"](http://jquery.com/)\r\n- [Martin Fowler, \"FluentInterface\"](https://www.martinfowler.com/bliki/FluentInterface.html)\r\n"},"__N_SSG":true}