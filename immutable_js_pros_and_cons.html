<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Immutable.js, pros and cons - WayneChoi.dev</title><meta name="author" content="Wayne Choi"/><meta name="description" content="How Immutable.js works with persistent data structures, and its pros and cons..."/><meta name="keywords" content="JavaScript,Library,Immutability"/><meta name="next-head-count" content="6"/><link rel="preload" href="https://waynechoi.dev/_next/static/css/595724bb477ee2da0de1.css" as="style"/><link rel="stylesheet" href="https://waynechoi.dev/_next/static/css/595724bb477ee2da0de1.css" data-n-g=""/><link rel="preload" href="https://waynechoi.dev/_next/static/css/63b98e12cd61a108a633.css" as="style"/><link rel="stylesheet" href="https://waynechoi.dev/_next/static/css/63b98e12cd61a108a633.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://waynechoi.dev/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://waynechoi.dev/_next/static/chunks/webpack-26d4ba47f3aad1b49b1b.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/framework-b97a0ed4f13ff8397343.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/main-c4f2541b93e4ae8b71f8.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/pages/_app-faa22e09c3bff8273e6e.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/575-765edfb4a154fafc480f.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/pages/%5Bslug%5D-89be9dc84306f9adcb10.js" defer=""></script><script src="https://waynechoi.dev/_next/static/mEic6uCP7GBYQTt8mwLvA/_buildManifest.js" defer=""></script><script src="https://waynechoi.dev/_next/static/mEic6uCP7GBYQTt8mwLvA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__1ROar"><header class="layout_header__MPs9E theme_light__2lu4I"><div class="header_container__2Vvjg"><div class="header_header__3lGRs"><button class="header_mobileMenuButton__1vVY8"><img alt="menu" src="https://waynechoi.dev/images/menu.svg"/></button><a class="header_name__2PEvs" href="/">WayneChoi.dev</a><ul class="header_list__2sooW"><li class="header_item_list_item__33J-y"><div><a href="/">HOME</a></div></li><li class="header_item_list_item__33J-y"><div><a href="/about">ABOUT</a></div></li><li class="header_item_list_item__33J-y"><div><a href="/portfolio">PORTFOLIO</a></div></li><li><button class="header_cliButton__3vGpm"><img src="https://waynechoi.dev/images/cli.png"/></button></li></ul><div class="header_searchBar__3VAZB"><form class="search_bar_container__2559w theme_light__2lu4I"><input type="text" id="keyword" placeholder="keywords..." required="" class="theme_light__2lu4I"/><button type="submit"><img alt="search" src="https://waynechoi.dev/images/search.svg"/></button></form></div><button class="header_mobileSearchButton__1r9xs"><img alt="search" src="https://waynechoi.dev/images/search.svg"/></button></div></div></header><section class="layout_contents__wGaub"><div class="blog_container__3EBzV"><div class="blog_tagWrapper__sYhAm"><span class="blog_tag__2jFK0">#<!-- -->JavaScript</span><span class="blog_tag__2jFK0">#<!-- -->Library</span><span class="blog_tag__2jFK0">#<!-- -->Immutability</span></div><h1 class="blog_h1__3s5r-">Immutable.js, pros and cons</h1><span class="blog_date__2SU8B">Oct 14, 2021</span><div class="blog_content__mgCMi"><div><div><p>We need to keep original data to avoid side effects. If it is primitive data type, there is nothing to care about. If it is an object, we normally copy and manipulate it to keep the original data immutable. In this way, we might get problem when we deal with large data.</p><p>To keep the original object, we need to deep copy it. It means we need to allocate the space in memory for the entire object, even all of the stuff that didn&#x27;t change. The both time and space complexity will be so bad. The code runs slow.</p><p>There are many of libraries to solve this problem, and I picked Immutable.js. It is a library to support immutable data structure, supported by Facebook. I would explain how it deal with immutability efficiently, and its disadvantages.</p><h2 id="how-immutablejs-works">How Immutable.js works</h2><pre><code class="lang-js">const { Map } = require(&quot;immutable&quot;);

const map1 = Map({ a: 1, b: 2, c: 3 });
const map2 = map1.set(&quot;b&quot;, 50);

console.log(map1.get(&quot;b&quot;)); // 2
console.log(map2.get(&quot;b&quot;)); // 50
console.log(map1 == map2); // false</code></pre><p>I made map1 object, then executed map1.set to change a value with key &quot;b&quot;. It did not change a value of key &quot;b&quot; in map1, but returned new object, map2, with new value of key &quot;b&quot;.</p><p>It looks like copying whole object and change one value, but worked totally different inside. Map1 and map2 objects are sharing values just except the changed value to minimize consuming memory. It is implemented by persistent data structures.</p><hr/><pre><code class="lang-js">const { fromJS } = require(&quot;immutable&quot;);

const nested = fromJS({ a: { b: { c: [3, 4, 5] } } });
const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }

console.log(nested);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }
console.log(nested2);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
console.log(nested == nested2); // false</code></pre><p>The collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON.</p><h2 id="persistent-data-structures">Persistent data structures</h2><p>In computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure.</p><p>It is commonly used in functional programming to enforce immutability. Many of languages with functional programming paradigm has implementations of persistent data structures, but JavaScript does not. Immutable.js is a library to support this to JavaScript.</p><p>It is optimized with trie data structure. I will provide an example below to understand easily.</p><hr/><pre><code class="lang-js">const data = {
  to: 7,
  tea: 3,
  ted: 4,
  ten: 12,
  A: 15,
  i: 11,
  in: 5,
  inn: 9,
};</code></pre><p><img alt="trie" src="/https://waynechoi.dev/images/posts/trie.png"/></p><p>I made an JS object, and created a trie with same keys and values. A trie is a type of tree where the leaves hold the values, and the paths from the root to the values represent the keys. So I can access a value by traversing the tree to get one letter at a time.</p><hr/><p><img alt="trie" src="/images/posts/trie_path.png"/></p><p>For example, if I want to get a value with a key, &#x27;ted&#x27;, I can start from root, and follow the paths represented &#x27;t&#x27;, &#x27;e&#x27;, and &#x27;d&#x27;. I arrived at a node that contains 4.</p><hr/><p><img alt="trie" src="/images/posts/trie_changed.png"/></p><p>I changed the value at the key &#x27;ted&#x27; from 4 to 8. Other nodes are still used. With this structures, only few nodes are recreated when we change a single item,</p><h2 id="disadvantages-of-immutablejs">Disadvantages of Immutable.js</h2><p>All the data structure implemented with Immutable.js are custom object. It means it is not JSON format. JSON is widely used format to communicate. If we use custom objects like data structures of Immutable.js, we need to convert them to JSON format first. It consumes time and memory, and it is a huge consumption when data is large.</p><p>In addition, we cannot use methods of Object and Array object in Immutable.js data structures. It raises the running curve, and dependency to a specific library.</p><h2 id="references">References</h2><ul><li><a href="https://youtu.be/Wo0qiGPSV-s">Anjana Vakil: Immutable data structures for functional JS | JSConf EU</a></li><li><a href="https://immutable-js.com/">Immutable.js</a></li><li><a href="https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56">How Immutable Data Structures (E.g. Immutable.js) are Optimized</a></li><li><a href="https://en.wikipedia.org/wiki/Persistent_data_structure#Trees">Wikipedia</a></li><li>함수형 자바스크립트 프로그래밍 - 유인동</li></ul></div></div></div><div id="utterances_container"></div></div></section><footer class="layout_footer__2KiKH">(C) <!-- -->2021<!-- -->. Wonjun Choi. All rights reserved.</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Immutable.js, pros and cons","date":"Oct 14, 2021","tag":["JavaScript","Library","Immutability"],"excerpt":"How Immutable.js works with persistent data structures, and its pros and cons...","content":"\nWe need to keep original data to avoid side effects. If it is primitive data type, there is nothing to care about. If it is an object, we normally copy and manipulate it to keep the original data immutable. In this way, we might get problem when we deal with large data.\n\nTo keep the original object, we need to deep copy it. It means we need to allocate the space in memory for the entire object, even all of the stuff that didn't change. The both time and space complexity will be so bad. The code runs slow.\n\nThere are many of libraries to solve this problem, and I picked Immutable.js. It is a library to support immutable data structure, supported by Facebook. I would explain how it deal with immutability efficiently, and its disadvantages.\n\n## How Immutable.js works\n\n```js\nconst { Map } = require(\"immutable\");\n\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = map1.set(\"b\", 50);\n\nconsole.log(map1.get(\"b\")); // 2\nconsole.log(map2.get(\"b\")); // 50\nconsole.log(map1 == map2); // false\n```\n\nI made map1 object, then executed map1.set to change a value with key \"b\". It did not change a value of key \"b\" in map1, but returned new object, map2, with new value of key \"b\".\n\nIt looks like copying whole object and change one value, but worked totally different inside. Map1 and map2 objects are sharing values just except the changed value to minimize consuming memory. It is implemented by persistent data structures.\n\n---\n\n```js\nconst { fromJS } = require(\"immutable\");\n\nconst nested = fromJS({ a: { b: { c: [3, 4, 5] } } });\nconst nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\n\nconsole.log(nested);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }\nconsole.log(nested2);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\nconsole.log(nested == nested2); // false\n```\n\nThe collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON.\n\n## Persistent data structures\n\nIn computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure.\n\nIt is commonly used in functional programming to enforce immutability. Many of languages with functional programming paradigm has implementations of persistent data structures, but JavaScript does not. Immutable.js is a library to support this to JavaScript.\n\nIt is optimized with trie data structure. I will provide an example below to understand easily.\n\n---\n\n```js\nconst data = {\n  to: 7,\n  tea: 3,\n  ted: 4,\n  ten: 12,\n  A: 15,\n  i: 11,\n  in: 5,\n  inn: 9,\n};\n```\n\n![trie](/images/posts/trie.png)\n\nI made an JS object, and created a trie with same keys and values. A trie is a type of tree where the leaves hold the values, and the paths from the root to the values represent the keys. So I can access a value by traversing the tree to get one letter at a time.\n\n---\n\n![trie](/images/posts/trie_path.png)\n\nFor example, if I want to get a value with a key, 'ted', I can start from root, and follow the paths represented 't', 'e', and 'd'. I arrived at a node that contains 4.\n\n---\n\n![trie](/images/posts/trie_changed.png)\n\nI changed the value at the key 'ted' from 4 to 8. Other nodes are still used. With this structures, only few nodes are recreated when we change a single item,\n\n## Disadvantages of Immutable.js\n\nAll the data structure implemented with Immutable.js are custom object. It means it is not JSON format. JSON is widely used format to communicate. If we use custom objects like data structures of Immutable.js, we need to convert them to JSON format first. It consumes time and memory, and it is a huge consumption when data is large.\n\nIn addition, we cannot use methods of Object and Array object in Immutable.js data structures. It raises the running curve, and dependency to a specific library.\n\n## References\n\n- [Anjana Vakil: Immutable data structures for functional JS | JSConf EU](https://youtu.be/Wo0qiGPSV-s)\n- [Immutable.js](https://immutable-js.com/)\n- [How Immutable Data Structures (E.g. Immutable.js) are Optimized](https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56)\n- [Wikipedia](https://en.wikipedia.org/wiki/Persistent_data_structure#Trees)\n- 함수형 자바스크립트 프로그래밍 - 유인동\n"},"__N_SSG":true},"page":"/[slug]","query":{"slug":"immutable_js_pros_and_cons"},"buildId":"mEic6uCP7GBYQTt8mwLvA","assetPrefix":"https://waynechoi.dev","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>