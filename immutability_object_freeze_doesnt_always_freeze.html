<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Immutability (1) - Object.freeze() doesn&#x27;t always freeze - WayneChoi.dev</title><meta name="author" content="Wayne Choi"/><meta name="description" content="Explain primitive and reference data type of JavaScript, and immutability of object..."/><meta name="keywords" content="JavaScript,Immutability"/><meta name="next-head-count" content="6"/><link rel="preload" href="https://waynechoi.dev/_next/static/css/595724bb477ee2da0de1.css" as="style"/><link rel="stylesheet" href="https://waynechoi.dev/_next/static/css/595724bb477ee2da0de1.css" data-n-g=""/><link rel="preload" href="https://waynechoi.dev/_next/static/css/67487a99917033bdcbc7.css" as="style"/><link rel="stylesheet" href="https://waynechoi.dev/_next/static/css/67487a99917033bdcbc7.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://waynechoi.dev/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://waynechoi.dev/_next/static/chunks/webpack-26d4ba47f3aad1b49b1b.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/framework-b97a0ed4f13ff8397343.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/main-c4f2541b93e4ae8b71f8.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/pages/_app-faa22e09c3bff8273e6e.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/575-765edfb4a154fafc480f.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/pages/%5Bslug%5D-89be9dc84306f9adcb10.js" defer=""></script><script src="https://waynechoi.dev/_next/static/Q9w05WAlte72mFtEJXlMV/_buildManifest.js" defer=""></script><script src="https://waynechoi.dev/_next/static/Q9w05WAlte72mFtEJXlMV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__1ROar"><header class="layout_header__MPs9E theme_light__2lu4I"><div class="header_container__2Vvjg"><div class="header_header__3lGRs"><button class="header_mobileMenuButton__1vVY8"><img alt="menu" src="https://waynechoi.dev/images/menu.svg"/></button><a class="header_name__2PEvs" href="/">WayneChoi.dev</a><ul class="header_list__2sooW"><li class="header_item_list_item__33J-y"><div><a href="/">HOME</a></div></li><li class="header_item_list_item__33J-y"><div><a href="/about">ABOUT</a></div></li><li class="header_item_list_item__33J-y"><div><a href="/portfolio">PORTFOLIO</a></div></li><li><button class="header_cliButton__3vGpm"><img src="https://waynechoi.dev/images/cli.png"/></button></li></ul><div class="header_searchBar__3VAZB"><form class="search_bar_container__2559w theme_light__2lu4I"><input type="text" id="keyword" placeholder="keywords..." required="" class="theme_light__2lu4I"/><button type="submit"><img alt="search" src="https://waynechoi.dev/images/search.svg"/></button></form></div><button class="header_mobileSearchButton__1r9xs"><img alt="search" src="https://waynechoi.dev/images/search.svg"/></button></div></div></header><section class="layout_contents__wGaub"><div class="blog_container__3EBzV"><div class="blog_tagWrapper__sYhAm"><span class="blog_tag__2jFK0">#<!-- -->JavaScript</span><span class="blog_tag__2jFK0">#<!-- -->Immutability</span></div><h1 class="blog_h1__3s5r-">Immutability (1) - Object.freeze() doesn&#x27;t always freeze</h1><span class="blog_date__2SU8B">Sep 23, 2021</span><div class="blog_content__mgCMi"><div><div><p>Immutability in JavaScript is getting more attention, while functional programming paradigm is on the rise. One of the important features of functional programming is that it has no side-effect.</p><p>A side effect is any application state change that is observable outside the called function other than its return value. It cause more problems by concurrency in an application. JavaScript is single thread language though, execution environment (browser and node.js) process various task at the same time. To avoid side effects, we need to keep the state outside the function immutable.</p><p>We can declare and assign immutable primitive variable with &#x27;const&#x27; keyword, and keep properties of an object with &#x27;Object.freeze()&#x27; method. The freeze method, however, does not always make objects immutable.</p><p>In this post, I would like to explain why &#x27;Object.freeze()&#x27; method is not complete way to make an object immutable, and to illustrate this, I need to deal with data type of JavaScript first.</p><h2 id="data-type-of-javascript">Data type of JavaScript</h2><p>JavaScript has 2 kinds of data types. One is primitive, and other is reference. Reference type is object which including array and function, and primitive type values are below.</p><ul><li>string</li><li>number</li><li>bigint</li><li>boolean</li><li>undefined</li><li>symbol</li><li>null</li></ul><h2 id="primitive-type">Primitive type</h2><pre><code class="lang-js">let p1; // declare variable
p = 1; // assign 1 (1000)

let p2 = 1; //assign 1 (1000)
console.log(p1 === p2); // true

p = 2; // reassign 2 (1001)</code></pre><table><thead><tr><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table><p>I declared a variable p1 and assigned number 1 to p1. Number 1 was not assigned to p1 directly, but allocated to memory first, and the memory address of number 1 is assigned to p1. Let&#x27;s suppose the address of number 1 is &#x27;1000&#x27;. (All of memory address in this post is hypothetical to help understand memory allocation of JavaScript)</p><p>I declared new variable p2, and assigned number 1 to p2. The same memory address, &#x27;1000&#x27;, was assigned to p2. Number 1 is primitive type data, and immutable.</p><p>And I reassigned number 2 to p1. At this time, number 1 in the memory &#x27;1000&#x27; won&#x27;t be changed. Number 2 is allocated to the other space of memory, and its address &#x27;1001&#x27; is assigned to p1. (I would not deal with garbage collection to free memory in this post)</p><h2 id="object">Object</h2><pre><code class="lang-js">let o1 = { name: &quot;choi&quot; }; // 2000
let o2 = { name: &quot;choi&quot; }; // 2001

console.log(o1 === o2); // false</code></pre><table><thead><tr><th>2000</th><th>2001</th></tr></thead><tbody><tr><td>{ name : &#x27;choi&#x27; }</td><td>{ name : &#x27;choi&#x27; }</td></tr></tbody></table><p>Object is basically mutable. If I declare two variables, and assigned objects which have same keys and values to those variables, two different memory addresses are assigned to each ones. Object is reference type data.</p><h2 id="copy">Copy</h2><pre><code class="lang-js">let p1 = 1;
let p2 = p1;

console.log(p1); // 1
console.log(p2); // 1

p1 = 2;

console.log(p1); // 2
console.log(p2); // 1</code></pre><p>It is simple to copy primitive type data. Primitive type data is immutable, so if I copied then changed one data, it doesn&#x27;t affect the other one.</p><hr/><pre><code class="lang-js">let o1 = { name: &quot;choi&quot; };
let o2 = o1;

console.log(o1); // { name: &quot;choi&quot; }
console.log(o2); // { name: &quot;choi&quot; }
console.log(o1 === o2); // true

o2.name = &quot;kim&quot;;

console.log(o1); // { name: &quot;kim&quot; }
console.log(o2); // { name: &quot;kim&quot; }
console.log(o1 === o2); // true</code></pre><table><thead><tr><th>2000</th></tr></thead><tbody><tr><td>{ name : <del>&#x27;choi&#x27;</del> &#x27;kim&#x27; }</td></tr></tbody></table><p>It, however, does work in different way for an object to copy. I assigned one variable, o1, which is assigned an object, to other variable, o2. I changed one of them, then it affects other variables as well. Object is reference type value, so both variable reference same object with same memory address.</p><hr/><pre><code class="lang-js">let o1 = { name: &quot;choi&quot; };
let o2 = Object.assign({}, o1);

console.log(o1); // { name: &quot;choi&quot; }
console.log(o2); // { name: &quot;choi&quot; }
console.log(o1 === o2); // false

o2.name = &quot;kim&quot;;

console.log(o1); // { name: &quot;choi&quot; }
console.log(o2); // { name: &quot;kim&quot; }</code></pre><table><thead><tr><th>2000</th><th>2001</th></tr></thead><tbody><tr><td>{ name : &#x27;choi&#x27; }</td><td>{ name : <del>&#x27;choi&#x27;</del> &#x27;kim&#x27; }</td></tr></tbody></table><p>If we did not mean to change the property of the original object, it could cause serious errors of an application. To keep the o1 object immutable, we can use Object.assign() to copy an object. (If it is an array, we can use Array.concat() as well.)</p><h2 id="objectfreeze">Object.freeze()</h2><pre><code class="lang-js">let o1 = { name: &quot;choi&quot; };
Object.freeze(o1);

o1.name = &quot;kim&quot;;
o1.age = 30; // even cannot add new properties

console.log(o1); // { name: &quot;choi&quot; }</code></pre><p>Finally we reached the freeze method. It freeze all properties of an object. we can block to change the original object from the very beginning with this method.</p><h2 id="const-vs-freeze">Const vs Freeze</h2><pre><code class="lang-js">let o1 = { name: &quot;choi&quot; };
Object.freeze(o1);

console.log(o1); // { name: &quot;choi&quot; };

o1 = &quot;hello world&quot;;

console.log(o1); // hello world

const o2 = { name: &quot;choi&quot; };

o2 = &quot;hello world&quot;; // Uncaught TypeError: Assignment to constant variable.</code></pre><p>Const keyword is for immutable reference, and the freeze method is for immutable value. I declared variable o1 with let keyword and assigned an object to it. Then I freezed it.
I can still reassign other value to o1.
But if I make same variable o2 but with const keyword, I cannot reassign, even though I wouldn&#x27;t freeze.</p><h2 id="cannot-freeze-nested-object">Cannot freeze Nested Object</h2><pre><code class="lang-js">let o1 = { name: &quot;choi&quot;, occupation: { job: &quot;boat builder&quot; } };
Object.freeze(o1);

o1.name = kim;
o1.occupation.job = &quot;software engineer&quot;;

console.log(o1); // { name : &quot;choi&quot;, occupation : { job : &quot;software engineer&quot;}}
// name hasn&#x27;t changed, but job has

let o2 = Object.assign({}, o1);
o2.name = &quot;kim&quot;;
o2.occupation.job = &quot;chef&quot;;

console.log(o1); // { name : &quot;choi&quot;, occupation : { job : &quot;chef&quot;}}
console.log(o2); // { name : &quot;kim&quot;, occupation : { job : &quot;chef&quot;}}</code></pre><p>If values of one or multiple properties are reference type, aka nested object, both assign and freeze methods can not keep the original object immutable when cloning. They are called shallow freeze and clone.</p><hr/><pre><code class="lang-js">function deepFreeze(object) {
  var propNames = Object.getOwnPropertyNames(object);

  for (let name of propNames) {
    let value = object[name];
    object[name] =
      value &amp;&amp; typeof value === &quot;object&quot; ? deepFreeze(value) : value;
  }

  return Object.freeze(object);
}</code></pre><p>If an object is nested with only one layer, we can freeze each properties with reference type value. It, however, is not easy to freeze all layers when the object is nested much deeper.</p><p>We can implement a function to deep freeze an object with recursion, or can use a library to support immutable data structure like immutable.js.</p><hr/><ul><li><strong>Immutability (1) - Object.freeze() doesn&#x27;t always freeze</strong></li><li><a href="https://waynechoi.dev/immutability_immutable_js_pros_and_cons">Immutability (2) - Immutable.js, pros and cons</a></li></ul><h2 id="references">References</h2><ul><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">Master the JavaScript Interview: What is Functional Programming? - Eric Elliott</a></li><li><a href="https://youtu.be/Wo0qiGPSV-s">Anjana Vakil: Immutable data structures for functional JS | JSConf EU</a></li><li>함수형 자바스크립트 프로그래밍 - 유인동</li></ul></div></div></div><div id="utterances_container"></div></div></section><footer class="layout_footer__2KiKH">(C) <!-- -->2021<!-- -->. Wonjun Choi. All rights reserved.</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Immutability (1) - Object.freeze() doesn't always freeze","date":"Sep 23, 2021","tag":["JavaScript","Immutability"],"excerpt":"Explain primitive and reference data type of JavaScript, and immutability of object...","content":"\nImmutability in JavaScript is getting more attention, while functional programming paradigm is on the rise. One of the important features of functional programming is that it has no side-effect.\n\nA side effect is any application state change that is observable outside the called function other than its return value. It cause more problems by concurrency in an application. JavaScript is single thread language though, execution environment (browser and node.js) process various task at the same time. To avoid side effects, we need to keep the state outside the function immutable.\n\nWe can declare and assign immutable primitive variable with 'const' keyword, and keep properties of an object with 'Object.freeze()' method. The freeze method, however, does not always make objects immutable.\n\nIn this post, I would like to explain why 'Object.freeze()' method is not complete way to make an object immutable, and to illustrate this, I need to deal with data type of JavaScript first.\n\n## Data type of JavaScript\n\nJavaScript has 2 kinds of data types. One is primitive, and other is reference. Reference type is object which including array and function, and primitive type values are below.\n\n- string\n- number\n- bigint\n- boolean\n- undefined\n- symbol\n- null\n\n## Primitive type\n\n```js\nlet p1; // declare variable\np = 1; // assign 1 (1000)\n\nlet p2 = 1; //assign 1 (1000)\nconsole.log(p1 === p2); // true\n\np = 2; // reassign 2 (1001)\n```\n\n| 1000 | 1001 |\n| ---- | ---- |\n| 1    | 2    |\n\nI declared a variable p1 and assigned number 1 to p1. Number 1 was not assigned to p1 directly, but allocated to memory first, and the memory address of number 1 is assigned to p1. Let's suppose the address of number 1 is '1000'. (All of memory address in this post is hypothetical to help understand memory allocation of JavaScript)\n\nI declared new variable p2, and assigned number 1 to p2. The same memory address, '1000', was assigned to p2. Number 1 is primitive type data, and immutable.\n\nAnd I reassigned number 2 to p1. At this time, number 1 in the memory '1000' won't be changed. Number 2 is allocated to the other space of memory, and its address '1001' is assigned to p1. (I would not deal with garbage collection to free memory in this post)\n\n## Object\n\n```js\nlet o1 = { name: \"choi\" }; // 2000\nlet o2 = { name: \"choi\" }; // 2001\n\nconsole.log(o1 === o2); // false\n```\n\n| 2000              | 2001              |\n| ----------------- | ----------------- |\n| { name : 'choi' } | { name : 'choi' } |\n\nObject is basically mutable. If I declare two variables, and assigned objects which have same keys and values to those variables, two different memory addresses are assigned to each ones. Object is reference type data.\n\n## Copy\n\n```js\nlet p1 = 1;\nlet p2 = p1;\n\nconsole.log(p1); // 1\nconsole.log(p2); // 1\n\np1 = 2;\n\nconsole.log(p1); // 2\nconsole.log(p2); // 1\n```\n\nIt is simple to copy primitive type data. Primitive type data is immutable, so if I copied then changed one data, it doesn't affect the other one.\n\n---\n\n```js\nlet o1 = { name: \"choi\" };\nlet o2 = o1;\n\nconsole.log(o1); // { name: \"choi\" }\nconsole.log(o2); // { name: \"choi\" }\nconsole.log(o1 === o2); // true\n\no2.name = \"kim\";\n\nconsole.log(o1); // { name: \"kim\" }\nconsole.log(o2); // { name: \"kim\" }\nconsole.log(o1 === o2); // true\n```\n\n| 2000                        |\n| --------------------------- |\n| { name : ~~'choi'~~ 'kim' } |\n\nIt, however, does work in different way for an object to copy. I assigned one variable, o1, which is assigned an object, to other variable, o2. I changed one of them, then it affects other variables as well. Object is reference type value, so both variable reference same object with same memory address.\n\n---\n\n```js\nlet o1 = { name: \"choi\" };\nlet o2 = Object.assign({}, o1);\n\nconsole.log(o1); // { name: \"choi\" }\nconsole.log(o2); // { name: \"choi\" }\nconsole.log(o1 === o2); // false\n\no2.name = \"kim\";\n\nconsole.log(o1); // { name: \"choi\" }\nconsole.log(o2); // { name: \"kim\" }\n```\n\n| 2000              | 2001                        |\n| ----------------- | --------------------------- |\n| { name : 'choi' } | { name : ~~'choi'~~ 'kim' } |\n\nIf we did not mean to change the property of the original object, it could cause serious errors of an application. To keep the o1 object immutable, we can use Object.assign() to copy an object. (If it is an array, we can use Array.concat() as well.)\n\n## Object.freeze()\n\n```js\nlet o1 = { name: \"choi\" };\nObject.freeze(o1);\n\no1.name = \"kim\";\no1.age = 30; // even cannot add new properties\n\nconsole.log(o1); // { name: \"choi\" }\n```\n\nFinally we reached the freeze method. It freeze all properties of an object. we can block to change the original object from the very beginning with this method.\n\n## Const vs Freeze\n\n```js\nlet o1 = { name: \"choi\" };\nObject.freeze(o1);\n\nconsole.log(o1); // { name: \"choi\" };\n\no1 = \"hello world\";\n\nconsole.log(o1); // hello world\n\nconst o2 = { name: \"choi\" };\n\no2 = \"hello world\"; // Uncaught TypeError: Assignment to constant variable.\n```\n\nConst keyword is for immutable reference, and the freeze method is for immutable value. I declared variable o1 with let keyword and assigned an object to it. Then I freezed it.\nI can still reassign other value to o1.\nBut if I make same variable o2 but with const keyword, I cannot reassign, even though I wouldn't freeze.\n\n## Cannot freeze Nested Object\n\n```js\nlet o1 = { name: \"choi\", occupation: { job: \"boat builder\" } };\nObject.freeze(o1);\n\no1.name = kim;\no1.occupation.job = \"software engineer\";\n\nconsole.log(o1); // { name : \"choi\", occupation : { job : \"software engineer\"}}\n// name hasn't changed, but job has\n\nlet o2 = Object.assign({}, o1);\no2.name = \"kim\";\no2.occupation.job = \"chef\";\n\nconsole.log(o1); // { name : \"choi\", occupation : { job : \"chef\"}}\nconsole.log(o2); // { name : \"kim\", occupation : { job : \"chef\"}}\n```\n\nIf values of one or multiple properties are reference type, aka nested object, both assign and freeze methods can not keep the original object immutable when cloning. They are called shallow freeze and clone.\n\n---\n\n```js\nfunction deepFreeze(object) {\n  var propNames = Object.getOwnPropertyNames(object);\n\n  for (let name of propNames) {\n    let value = object[name];\n    object[name] =\n      value \u0026\u0026 typeof value === \"object\" ? deepFreeze(value) : value;\n  }\n\n  return Object.freeze(object);\n}\n```\n\nIf an object is nested with only one layer, we can freeze each properties with reference type value. It, however, is not easy to freeze all layers when the object is nested much deeper.\n\nWe can implement a function to deep freeze an object with recursion, or can use a library to support immutable data structure like immutable.js.\n\n---\n\n- **Immutability (1) - Object.freeze() doesn't always freeze**\n- [Immutability (2) - Immutable.js, pros and cons](https://waynechoi.dev/immutability_immutable_js_pros_and_cons)\n\n## References\n\n- [Master the JavaScript Interview: What is Functional Programming? - Eric Elliott](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0)\n- [Anjana Vakil: Immutable data structures for functional JS | JSConf EU](https://youtu.be/Wo0qiGPSV-s)\n- 함수형 자바스크립트 프로그래밍 - 유인동\n"},"__N_SSG":true},"page":"/[slug]","query":{"slug":"immutability_object_freeze_doesnt_always_freeze"},"buildId":"Q9w05WAlte72mFtEJXlMV","assetPrefix":"https://waynechoi.dev","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>