<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="https://waynechoi.dev/_next/static/css/aaedc6b3366e5497f17c.css" as="style"/><link rel="stylesheet" href="https://waynechoi.dev/_next/static/css/aaedc6b3366e5497f17c.css" data-n-g=""/><link rel="preload" href="https://waynechoi.dev/_next/static/css/3b27d03bfc1782cbf357.css" as="style"/><link rel="stylesheet" href="https://waynechoi.dev/_next/static/css/3b27d03bfc1782cbf357.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://waynechoi.dev/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://waynechoi.dev/_next/static/chunks/webpack-26d4ba47f3aad1b49b1b.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/main-c4f2541b93e4ae8b71f8.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/pages/_app-4a215befa954bc3f5ab5.js" defer=""></script><script src="https://waynechoi.dev/_next/static/chunks/pages/cli-10bcfb0d4fc85feac593.js" defer=""></script><script src="https://waynechoi.dev/_next/static/MWH9VlghDW7Swbw8zluOq/_buildManifest.js" defer=""></script><script src="https://waynechoi.dev/_next/static/MWH9VlghDW7Swbw8zluOq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="cli_container__1OnSr"><div class="cli_contents__1MYUU"><pre class="cli_boat__WHCcj"><code>
                                          xxx
                                         xxxxx
                                        x xxx x
                                       x  xxx  x
                                      x   xxx   x
                                     x    xxx    x
                                    x     xxx     x
                                   x      xxx      x
                                  x       xxx       x
                                 x        xxx        x
                                x         xxx         x
                               x          xxx          x
                              x           xxx           x
                             x            xxx            x
                            x             xxx             x
                           x              xxx              x
                          x               xxx               x
                         x                xxx                x
                        x                 xxx                 x                               xxxxxx
                       x                  xxx                  x                              x     xxxxxx
                      x                   xxx                   x                            x      x
                     x                    xxx                    x                         x       x
                    x                     xxx                     x                       x       x
                   x                      xxx                      x                      x      x
                  x                       xxx                       x                    x      x
                 x                        xxx                        x                   x       x
                x                         xxxxxxxxxxxxxxxxxxxxxxxxxxxxx                    x    x
               xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx                                             x    x
                                          xxx                                            x    x
     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
      x                                                                                       x
       x                                                                                     x
        x                                                                                   x
~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-
~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;
~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-~&quot;^&quot;~-,._.,-
</code><code>
┌-------------------------------------------------------------------------------------------------------┐
│ xx     xx  xxxxx  xx    xx xxx    xx xxxxxxx  xxxxxx xx   xx  xxxxxx  xx     xxxxxx  xxxxxxx xx    xx │
│ xx     xx xx   xx  xx  xx  xxxx   xx xx      xx      xx   xx xx    xx xx     xx   xx xx      xx    xx │
│ xx  x  xx xxxxxxx   xxxx   xx xx  xx xxxxx   xx      xxxxxxx xx    xx xx     xx   xx xxxxx   xx    xx │
│ xx xxx xx xx   xx    xx    xx  xx xx xx      xx      xx   xx xx    xx xx     xx   xx xx       xx  xx  │
│  xxx xxx  xx   xx    xx    xx   xxxx xxxxxxx  xxxxxx xx   xx  xxxxxx  xx  x  xxxxxx  xxxxxxx   xxxx   │
└-------------------------------------------------------------------------------------------------------┘
</code></pre><p>Type &#x27;help&#x27; and press &#x27;enter&#x27; to get commands list.</p></div><form class="cli_cmd__v-2IF"><p class="cli_user__30Fjc">guest: ~<!-- -->$</p><input type="text" class="cli_input__1lXGt" autofocus="" value=""/></form></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"slug":"state_management_with_class_in_react","title":"State management with Class in React","date":"Mar 18, 2022","tag":["React","Architecture"],"excerpt":"To implement global state management with class and dependency injection in React application.","content":"\nI implemented a global state management to deal with JWT token and local storage in React application. This post is to share my concerns and how I solved them. The module is class-based. A React library to manage global statement, and window object to get and set local storage is injected from outside the class.\n\n## Why class?\n\nI struggled between class(to deal with action and status together) and function(with objects literal) to manage statements in this application.\n\nIf I decoupled to reduce dependence with class, it makes better maintainability, and easier test code. At the same time, it costs a lot to covert states from the class instance to the React library, and from the React library to the class instance.\n\nThere are various of dependency for frontend application, such as DOM, React libraries, and window object, so if it is decoupled too deep, the complexity of the application increases incredibly. So, I normally prefer not to use class to manage statement in frontend application.\n\nHowever, I picked class and dependency injection. All the action about authentication shares same statement, so I thought it costs more to inject all the dependency into every single function. The other reason was that the storage to store user information is different depend on user option. It would be better to be abstracted.\n\n## Recoil?\n\nEven if I manipulate the states in the class, I need to update states of a React library, because the members in the class does not affect DOM rendering in real time.\n\nI choose Recoil at first. But there was an issue. I can only access Recoil atoms in the RecoilRoot component. That means I cannot inject all methods to update Recoil atoms in main component. So I made the Initializer component under RecoilRoot component, and inject all the dependency with an initialization method in Initializer component.\n\n```typescript\n//app.tsx\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const date = new Date();\n  const auth = AuthService.getInstance(urlBase);\n\n  return (\n    \u003cRecoilRoot\u003e\n      \u003cInitializer auth={auth} date={date} /\u003e\n      \u003cLayout date={date} auth={auth}\u003e\n        \u003cComponent {...pageProps} auth={auth} urlBase={urlBase} /\u003e\n      \u003c/Layout\u003e\n    \u003c/RecoilRoot\u003e\n  );\n}\n\n//initializer.tsx\nimport { useEffect } from \"react\";\nimport { useRecoilState } from \"recoil\";\nimport { authState } from \"../../../atoms/auth\";\nimport { tokenState } from \"../../../atoms/token\";\nimport AuthService from \"../../../utils/modules/auth\";\n\ninterface IProps {\n  auth: AuthService;\n  date: Date;\n}\n\nexport default function Initializer({ auth, date }: IProps) {\n  const [token, setToken] = useRecoilState(tokenState);\n  const [isAuthorized, setIsAuthorized] = useRecoilState(authState);\n  useEffect(() =\u003e {\n    auth.init(setToken, setIsAuthorized, window, date);\n  }, []);\n  return \u003c\u003e\u003c/\u003e;\n}\n```\n\nIt is too complex. I thought about another alternative.\n\n## Context API\n\nThe higher the level of abstraction, the more difficult it is to customize. I decided to replace Recoil with context API. I did not use FLUX pattern which is the most commonly used with context API, but new pattern.\n\nIn the FLUX pattern, both action and states are injected to a Provider. I abstracted all the action to manage state in context with injecting into the class instance, and injected only states and the class instance to a Provider. I mean that it is to decouple all the state management logics.\n\n```typescript\nimport { createContext, ReactChild, useEffect, useState } from \"react\";\nimport AuthService, { AuthStatus } from \"../../services/auth/auth\";\n\nexport interface AuthProviderValue extends AuthStatus {\n  service: AuthService;\n}\nconst authServiceInstance = AuthService.getInstance();\nconst initialStatus: AuthStatus = { token: \"\", isAuth: \"\" };\nconst initialValue: AuthProviderValue = {\n  ...initialStatus,\n  service: authServiceInstance,\n};\n\nexport const authContext = createContext\u003cAuthProviderValue\u003e(initialValue);\n\ninterface IProps {\n  children: ReactChild;\n  urlBase: string;\n}\n\nconst AuthProvider = ({ children, urlBase }: IProps) =\u003e {\n  const [status, setStatus] = useState\u003cAuthStatus\u003e(initialStatus);\n\n  const date = new Date();\n  useEffect(() =\u003e {\n    authServiceInstance?.init(urlBase, window, date, setStatus);\n  }, []);\n\n  const value = {\n    service: authServiceInstance,\n    token: status.token,\n    isAuth: status.isAuth,\n  };\n\n  return \u003cauthContext.Provider value={value}\u003e{children}\u003c/authContext.Provider\u003e;\n};\n\nexport default AuthProvider;\n```\n\n## To be fixed\n\nThe branching process to figure out local storage to save user information is abstracted, so hard to be tested with unit tests. The test coverage of this service is about 80% now.\n\nI guess I could decouple this process with another class or static class to decouple.\n"},{"slug":"prevent_to_make_instance_repeatedly_in_react_component","title":"Prevent to make instance repeatedly in react component","date":"Dec 15, 2021","tag":["React","Issue"],"excerpt":"I had an issue to make instance repeatedly in react component, and fixed it.","content":"\nAll code is not real codes, but abstracted to understand this issue easily.\n\n```javascript\n// service/command.ts\nexport default class Command {\n  contentsContainer: HTMLDivElement;\n  posts: Post[];\n  curDir: string;\n\n  constructor(contentsContainer: HTMLDivElement, posts: Post[]) {\n    this.contentsContainer = contentsContainer;\n    this.posts = posts;\n    this.curDir = \"\";\n  }\n\n  cd() {\n    switch (this.curDir) {\n      case \"\":\n        this.curDir = \"/dir\";\n        break;\n\n      case \"/dir\":\n        this.curDir = \"\";\n        break;\n    }\n  }\n}\n\n// pages/cli.tsx\nexport default function Cli({ posts }: IProps) {\n\n  const [curDir, setCurDir] = useState(\"\");\n\n  const contentsElement = useRef\u003cHTMLDivElement\u003e(null);\n  const contentsContainer = contentsElement.current!;\n\n  const cliCommand = new Command(contentsContainer, posts);\n\n  const changeDirectory = () =\u003e {\n      cliCommand.cd(command);\n      setCurDir(cliCommand.curDir);\n  };\n  return (\n      ...\n  );\n}\n\nexport const getStaticProps: GetStaticProps = async () =\u003e {\n  const posts = getBlogList();\n  return {\n    props: {\n      posts,\n    },\n  };\n};\n\n```\n\nThis code is to implement cli command for my tech blog. It works well in unit testing, but I had an issue when user testing. Even if I change this.curDir member in cliCommand instance to the string \"/dir\", it keep changing to an empty string again.\n\nThe reason was the react component keep making new instance whenever the life cycle of itself was changed. I set the member, this.curDir, the empty string in constructor method, so it kept changing to empty string.\n\nI wanted to make an instance of Command class in the main component, \\_app.tsx, then inject the dependency into cli page component, but I can not access the arguments for constructor method, HTMLDivElement, and pages, in the main component. Because the business logic of getting pages need to access file system, but the main component of next.js was not supported for server-side.\n\n```javascript\n\n// service/command.ts\nexport default class Command {\n  contentsContainer!: HTMLDivElement;\n  posts!: Post[];\n  curDir: string;\n\n  constructor() {\n    this.curDir = \"\";\n  }\n\n  init(contentsContainer: HTMLDivElement, posts: Post[]) {\n    this.contentsContainer = contentsContainer;\n    this.posts = posts;\n  }\n\n  cd() {\n    switch (this.curDir) {\n      case \"\":\n        this.curDir = \"/dir\";\n        break;\n\n      case \"/dir\":\n        this.curDir = \"\";\n        break;\n    }\n  }\n}\n\n\n// pages/_app.tsx\nimport Command from \"../service/blog/command\";\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  const cliCommand = new Command();\n  return \u003cComponent {...pageProps} cliCommand={cliCommand} /\u003e\n}\n\nexport default MyApp;\n\n\n// pages/cli.tsx\nexport default function Cli({ cliCommand, posts }: IProps) {\n\n  const [curDir, setCurDir] = useState(\"\");\n\n  const contentsElement = useRef\u003cHTMLDivElement\u003e(null);\n  const contentsContainer = contentsElement.current!;\n\n  const changeDirectory = () =\u003e {\n      cliCommand.cd(command);\n      setCurDir(cliCommand.curDir);\n  };\n\n useEffect(() =\u003e {\n    cliCommand.init(contentsContainer, posts);\n  }, [contentsContainer, posts]);\n\n  return (\n      ...\n  );\n}\n\nexport const getStaticProps: GetStaticProps = async () =\u003e {\n  const posts = getBlogList();\n  return {\n    props: {\n      posts,\n    },\n  };\n};\n\n```\n\nTo figure it out, I removed all the arguments from the constructor method, and added an init method to set HTMLDivElement and pages members. Then I made an instance in main component, and pass it to the page component.\n"},{"slug":"immutability_immutable_js_pros_and_cons","title":"Immutability (2) - Immutable.js, pros and cons","date":"Oct 14, 2021","tag":["JavaScript","Library","Immutability"],"excerpt":"How Immutable.js works with persistent data structures, and its pros and cons...","content":"\nWe need to keep original data to avoid side effects. If it is primitive data type, there is nothing to care about. If it is an object, we normally copy and manipulate it to keep the original data immutable. In this way, we might get problem when we deal with large data.\n\nTo keep the original object, we need to deep copy it. It means we need to allocate the space in memory for the entire object, even all of the stuff that didn't change. The both time and space complexity will be so bad. The code runs slow.\n\nThere are many of libraries to solve this problem, and I picked Immutable.js. It is a library to support immutable data structure, supported by Facebook. I would explain how it deal with immutability efficiently, and its disadvantages.\n\n## How Immutable.js works\n\n```js\nconst { Map } = require(\"immutable\");\n\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconst map2 = map1.set(\"b\", 50);\n\nconsole.log(map1.get(\"b\")); // 2\nconsole.log(map2.get(\"b\")); // 50\nconsole.log(map1 == map2); // false\n```\n\nI made map1 object, then executed map1.set to change a value with key \"b\". It did not change a value of key \"b\" in map1, but returned new object, map2, with new value of key \"b\".\n\nIt looks like copying whole object and change one value, but worked totally different inside. Map1 and map2 objects are sharing values just except the changed value to minimize consuming memory. It is implemented by persistent data structures.\n\n---\n\n```js\nconst { fromJS } = require(\"immutable\");\n\nconst nested = fromJS({ a: { b: { c: [3, 4, 5] } } });\nconst nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\n\nconsole.log(nested);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }\nconsole.log(nested2);\n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }\nconsole.log(nested == nested2); // false\n```\n\nThe collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON.\n\n## Persistent data structures\n\nIn computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure.\n\nIt is commonly used in functional programming to enforce immutability. Many of languages with functional programming paradigm has implementations of persistent data structures, but JavaScript does not. Immutable.js is a library to support this to JavaScript.\n\nIt is optimized with trie data structure. I will provide an example below to understand easily.\n\n---\n\n```js\nconst data = {\n  to: 7,\n  tea: 3,\n  ted: 4,\n  ten: 12,\n  A: 15,\n  i: 11,\n  in: 5,\n  inn: 9,\n};\n```\n\n\u003cimg src=\"https://waynechoi.dev/images/posts/trie_original.png\"\u003e\n\nI made an JS object, and created a trie with same keys and values. A trie is a type of tree where the leaves hold the values, and the paths from the root to the values represent the keys. So I can access a value by traversing the tree to get one letter at a time.\n\n---\n\n\u003cimg src=\"https://waynechoi.dev/images/posts/trie_path.png\"\u003e\n\nFor example, if I want to get a value with a key, 'ted', I can start from root, and follow the paths represented 't', 'e', and 'd'. I arrived at a node that contains 4.\n\n---\n\n\u003cimg src=\"https://waynechoi.dev/images/posts/trie_changed.png\"\u003e\n\nI changed the value at the key 'ted' from 4 to 8. Other nodes are still used. With this structures, only few nodes are recreated when we change a single item,\n\n## Disadvantages of Immutable.js\n\nAll the data structure implemented with Immutable.js are custom object. It means it is not JSON format. JSON is widely used format to communicate. If we use custom objects like data structures of Immutable.js, we need to convert them to JSON format first. It consumes time and memory, and it is a huge consumption when data is large.\n\nIn addition, we cannot use methods of Object and Array object in Immutable.js data structures. It raises the running curve, and dependency to a specific library.\n\n---\n\n- [Immutability (1) - Object.freeze() doesn't always freeze](https://waynechoi.dev/immutability_object_freeze_doesnt_always_freeze)\n- **Immutability (2) - Immutable.js, pros and cons**\n\n## References\n\n- [Anjana Vakil: Immutable data structures for functional JS | JSConf EU](https://youtu.be/Wo0qiGPSV-s)\n- [Wikipedia](https://en.wikipedia.org/wiki/Persistent_data_structure#Trees)\n- [Immutable.js](https://immutable-js.com/)\n- [How Immutable Data Structures (E.g. Immutable.js) are Optimized](https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56)\n- 함수형 자바스크립트 프로그래밍 - 유인동\n"},{"slug":"immutability_object_freeze_doesnt_always_freeze","title":"Immutability (1) - Object.freeze() doesn't always freeze","date":"Sep 23, 2021","tag":["JavaScript","Immutability"],"excerpt":"Explain primitive and reference data type of JavaScript, and immutability of object...","content":"\nImmutability in JavaScript is getting more attention, while functional programming paradigm is on the rise. One of the important features of functional programming is that it has no side-effect.\n\nA side effect is any application state change that is observable outside the called function other than its return value. It cause more problems by concurrency in an application. JavaScript is single thread language though, execution environment (browser and node.js) process various task at the same time. To avoid side effects, we need to keep the state outside the function immutable.\n\nWe can declare and assign immutable primitive variable with 'const' keyword, and keep properties of an object with 'Object.freeze()' method. The freeze method, however, does not always make objects immutable.\n\nIn this post, I would like to explain why 'Object.freeze()' method is not complete way to make an object immutable, and to illustrate this, I need to deal with data type of JavaScript first.\n\n## Data type of JavaScript\n\nJavaScript has 2 kinds of data types. One is primitive, and other is reference. Reference type is object which including array and function, and primitive type values are below.\n\n- string\n- number\n- bigint\n- boolean\n- undefined\n- symbol\n- null\n\n## Primitive type\n\n```js\nlet p1; // declare variable\np = 1; // assign 1 (1000)\n\nlet p2 = 1; //assign 1 (1000)\nconsole.log(p1 === p2); // true\n\np = 2; // reassign 2 (1001)\n```\n\n| 1000 | 1001 |\n| ---- | ---- |\n| 1    | 2    |\n\nI declared a variable p1 and assigned number 1 to p1. Number 1 was not assigned to p1 directly, but allocated to memory first, and the memory address of number 1 is assigned to p1. Let's suppose the address of number 1 is '1000'. (All of memory address in this post is hypothetical to help understand memory allocation of JavaScript)\n\nI declared new variable p2, and assigned number 1 to p2. The same memory address, '1000', was assigned to p2. Number 1 is primitive type data, and immutable.\n\nAnd I reassigned number 2 to p1. At this time, number 1 in the memory '1000' won't be changed. Number 2 is allocated to the other space of memory, and its address '1001' is assigned to p1. (I would not deal with garbage collection to free memory in this post)\n\n## Object\n\n```js\nlet o1 = { name: \"choi\" }; // 2000\nlet o2 = { name: \"choi\" }; // 2001\n\nconsole.log(o1 === o2); // false\n```\n\n| 2000              | 2001              |\n| ----------------- | ----------------- |\n| { name : 'choi' } | { name : 'choi' } |\n\nObject is basically mutable. If I declare two variables, and assigned objects which have same keys and values to those variables, two different memory addresses are assigned to each ones. Object is reference type data.\n\n## Copy\n\n```js\nlet p1 = 1;\nlet p2 = p1;\n\nconsole.log(p1); // 1\nconsole.log(p2); // 1\n\np1 = 2;\n\nconsole.log(p1); // 2\nconsole.log(p2); // 1\n```\n\nIt is simple to copy primitive type data. Primitive type data is immutable, so if I copied then changed one data, it doesn't affect the other one.\n\n---\n\n```js\nlet o1 = { name: \"choi\" };\nlet o2 = o1;\n\nconsole.log(o1); // { name: \"choi\" }\nconsole.log(o2); // { name: \"choi\" }\nconsole.log(o1 === o2); // true\n\no2.name = \"kim\";\n\nconsole.log(o1); // { name: \"kim\" }\nconsole.log(o2); // { name: \"kim\" }\nconsole.log(o1 === o2); // true\n```\n\n| 2000                        |\n| --------------------------- |\n| { name : ~~'choi'~~ 'kim' } |\n\nIt, however, does work in different way for an object to copy. I assigned one variable, o1, which is assigned an object, to other variable, o2. I changed one of them, then it affects other variables as well. Object is reference type value, so both variable reference same object with same memory address.\n\n---\n\n```js\nlet o1 = { name: \"choi\" };\nlet o2 = Object.assign({}, o1);\n\nconsole.log(o1); // { name: \"choi\" }\nconsole.log(o2); // { name: \"choi\" }\nconsole.log(o1 === o2); // false\n\no2.name = \"kim\";\n\nconsole.log(o1); // { name: \"choi\" }\nconsole.log(o2); // { name: \"kim\" }\n```\n\n| 2000              | 2001                        |\n| ----------------- | --------------------------- |\n| { name : 'choi' } | { name : ~~'choi'~~ 'kim' } |\n\nIf we did not mean to change the property of the original object, it could cause serious errors of an application. To keep the o1 object immutable, we can use Object.assign() to copy an object. (If it is an array, we can use Array.concat() as well.)\n\n## Object.freeze()\n\n```js\nlet o1 = { name: \"choi\" };\nObject.freeze(o1);\n\no1.name = \"kim\";\no1.age = 30; // even cannot add new properties\n\nconsole.log(o1); // { name: \"choi\" }\n```\n\nFinally we reached the freeze method. It freeze all properties of an object. we can block to change the original object from the very beginning with this method.\n\n## Const vs Freeze\n\n```js\nlet o1 = { name: \"choi\" };\nObject.freeze(o1);\n\nconsole.log(o1); // { name: \"choi\" };\n\no1 = \"hello world\";\n\nconsole.log(o1); // hello world\n\nconst o2 = { name: \"choi\" };\n\no2 = \"hello world\"; // Uncaught TypeError: Assignment to constant variable.\n```\n\nConst keyword is for immutable reference, and the freeze method is for immutable value. I declared variable o1 with let keyword and assigned an object to it. Then I freezed it.\nI can still reassign other value to o1.\nBut if I make same variable o2 but with const keyword, I cannot reassign, even though I wouldn't freeze.\n\n## Cannot freeze Nested Object\n\n```js\nlet o1 = { name: \"choi\", occupation: { job: \"boat builder\" } };\nObject.freeze(o1);\n\no1.name = kim;\no1.occupation.job = \"software engineer\";\n\nconsole.log(o1); // { name : \"choi\", occupation : { job : \"software engineer\"}}\n// name hasn't changed, but job has\n\nlet o2 = Object.assign({}, o1);\no2.name = \"kim\";\no2.occupation.job = \"chef\";\n\nconsole.log(o1); // { name : \"choi\", occupation : { job : \"chef\"}}\nconsole.log(o2); // { name : \"kim\", occupation : { job : \"chef\"}}\n```\n\nIf values of one or multiple properties are reference type, aka nested object, both assign and freeze methods can not keep the original object immutable when cloning. They are called shallow freeze and clone.\n\n---\n\n```js\nfunction deepFreeze(object) {\n  var propNames = Object.getOwnPropertyNames(object);\n\n  for (let name of propNames) {\n    let value = object[name];\n    object[name] =\n      value \u0026\u0026 typeof value === \"object\" ? deepFreeze(value) : value;\n  }\n\n  return Object.freeze(object);\n}\n```\n\nIf an object is nested with only one layer, we can freeze each properties with reference type value. It, however, is not easy to freeze all layers when the object is nested much deeper.\n\nWe can implement a function to deep freeze an object with recursion, or can use a library to support immutable data structure like immutable.js.\n\n---\n\n- **Immutability (1) - Object.freeze() doesn't always freeze**\n- [Immutability (2) - Immutable.js, pros and cons](https://waynechoi.dev/immutability_immutable_js_pros_and_cons)\n\n## References\n\n- [Master the JavaScript Interview: What is Functional Programming? - Eric Elliott](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0)\n- [Anjana Vakil: Immutable data structures for functional JS | JSConf EU](https://youtu.be/Wo0qiGPSV-s)\n- 함수형 자바스크립트 프로그래밍 - 유인동\n"},{"slug":"variable_declaration_in_javascript_modules","title":"Variable declaration in JavaScript Modules","date":"Sep 2, 2021","tag":["JavaScript"],"excerpt":"In module JavaScript, however, \"this\" refers to \"undefined\" in the top level context...","content":"\nThis study started with only a single line of code I did not understand.\n\n```javascript\n// type = \"module\"\nconsole.log(this); // undefined\n```\n\n## Where the hell is \"window\"?\n\nIn the global execution context (outside of any function), \"this\" refers to the global object. If its runtime environment is a browser, it is \"window\". In module JavaScript, however, \"this\" refers to \"undefined\" in the top level context.\n\nModules are imported into the scope of single scripts. They cannot be called from global scope.\n\nModules have a lexical top-level scope. This means that for example, running var foo = 42; within a module does not create a global variable named foo, accessible through window.foo in a browser, although that would be the case in a classic script.\n\nSimilarly, the this within modules does not refer to the global this, and instead is undefined.\n\n## Variables Declaration\n\nAll variables in JavaScript is properties of objects, and a global variable is assigned to a property of global object.\n\n```javascript\nvar a = \"hi\";\nconsole.log(a); // hi\nconsole.log(window.a); // hi\nconsole.log(this.a); // hi\n```\n\nWhat object is variables, declared in top-level scope of modules, assigned to?\n\nWhen variables is declared, it is assigned to a property of LexicalEnvironment component in execution context. The variables in top-level scope of modules are also assigned to LexicalEnvironment like any other execution contexts, but not global object like global variable. Only global variable is assigned to the global object, and then LexicalEnvironment refer the global object.\n\n## \"var\" and \"let\"\n\nFor both modules and commonjs, variables declared suing the \"let\", and constants are not assigned to a global property, but only LexicalEnvironment.\n\n```javascript\nlet a = \"hi\";\nconsole.log(a); // hi\nconsole.log(window.a); // undefined\nconsole.log(this.a); // undefined\n```\n\n## References\n\n- [this - JavaScript | MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/this)\n- [JavaScript modules - JavaScript | MDN](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Modules)\n- [JavaScript modules · V8](https://v8.dev/features/modules#mjs)\n"},{"slug":"neoquery_the_simplified_jquery","title":"NeoQuery, the simplified jQuery","date":"Sep 1, 2021","tag":["JavaScript","Library","jQuery"],"excerpt":"I made a DOM manipulation library, and I was highly motivated from jQuery...","content":"\njQuery, which used to be a market-dominant library, is getting less attention in 2021. It is not an attractive option for new projects anymore, but legacy. Most browsers support web standards, and JavaScript improved a lot with ES6 update. We got fancy api like querySelectorAll() instead of getElementById(), and it is as convenient as jQuery methods.\n\nIn addition, jQuery is too heavy. In modern JS ecosystem, modularized library is recommend to use. jQuery, however, does have too many features. It helps Dom manipulation, CSS styling, event handling, animation, and ajax. They could be covered with modern JavaScript, or sometimes other modularized library like Axios.\n\nBut I believe jQuery syntax still works well. Especially its way to manipulate DOM with chaining method is still attractive. So I made a library, which is highly motivated from jQuery, and has similar methods and syntax, to manipulate DOM. It is [NeoQuery.](https://github.com/waynethebb/neoquery)\n\n## Fluent Interface\n\nA fluent interface is normally implemented by using method chaining to implement method cascading. jQuery is one of the most representative examples of use.\n\n```javascript\n//jQuery example\n$(\"#textNode\").css(\"color\", \"red\").appendTo(\"#someDiv\");\n```\n\nIt is implemented by having each method return the object to which it is attached, often referred to as \"this\". Stated more abstractly, a fluent interface relays the instruction context of a subsequent call in method chaining, where generally the context is\n\n- Defined through the return value of a called method\n- Self-referential, where the new context is equivalent to the last context\n- Terminated through the return of a void context\n\n```javascript\nClass Person{\n    constructor(){\n        this.name;\n        this.age;\n    }\n\n    setName(name) {\n        this.name = name\n        return this\n    }\n\n    setAge(age) {\n        this.age = age\n        return this\n    }\n\n    sayHi() {\n        console.log(`Hi. I am ${this.name}, ${age} years old.`)\n        return this\n    }\n}\n\nnew Person().setName(\"Wayne\").setAge(\"30\").sayHi();\n//\"Hi. I am Wayne, 30 years old.\"\n```\n\nI tried to implement chaining method with similar syntax as jQuery. I didn't export class, but export $() function which create instance of the fluent interface class, and return method of the class.\n\n```javascript\nexport default function $(query) {\n  return neoQuery.selectQuery(query);\n}\n\nclass NeoQuery {\n  constructor() {\n    this.element;\n  }\n\n  selectQuery(query) {\n    const newElement = document.querySelectorAll(query);\n    this.element = newElement;\n    return this;\n  }\n\n  addClass() {\n    ...\n    this.element = ...\n    return this;\n  }\n\n  appendTo(query) {\n    ...\n    this.element = ...\n    return this;\n  }\n  ...\n}\n\n$(\"#textNode\").addClass(\"myClass\").appendTo(\"#someDiv\");\n```\n\n## $()\n\nThe function, $(), is to create new instance, and start chaining methods. It has three features.\n\n```javascript\n$(callback);\n// Binds a function to be executed when the DOM has finished loading.\n// It doesn't chain methods.\n// ex) $(()=\u003e{console.log(\"ready\")})\n\n$(selector);\n// Selects DOM elements with a CSS selector\n// ex) $( \"div.foo\" ).---\n\n$(html);\n//Creates DOM elements from the provided string of raw HTML.\n// ex) $(\"\u003cdiv\u003etest\u003c/div\u003e\").---\n```\n\n## Methods\n\nI made all methods (except $()), have only one feature. It is to avoid unnecessary logic to categorize arguments for running different feature in one methods, and has more intuitive interface.\n\n```javascript\n// jQuery\nattr(attributeName); // Get the value of attributes\nattr(attributeName, value); // Set attributes\n\n// neoQuery\nattr(attributeName); // Get the value of an attributes\naddAttr(attributeName, value); // Set attributes\n```\n\n## Other features\n\nI didn't create ajax and animation features, and minimize styling and event handling features. I intended to make this library as light as possible.\n\n### Styling\n\n- addCss(propertyName, value)\n- removeCss(propertyName)\n- show()\n- hide()\n\nI believe in-line styling need to be rejected, so I did not implement other styling methods. Unlike jQuery, those method can get only one property name as an argument.(\"css()\" the jQuery method can get object for css properties)\n\n\"show()\" and \"hide()\" methods was only exception. I think those methods are more like DOM control, and it does not conflict against other style properties.\n\n### Event\n\n- on(event, callback)\n- one(event, callback)\n- off(event, callback)\n\nI did not make other features to create event listener, but methods we can use with the browser event types.\n\n## References\n\n- [\"jQuery: The write less, do more, JavaScript library\"](http://jquery.com/)\n- [Martin Fowler, \"Fluent Interface\"](https://www.martinfowler.com/bliki/FluentInterface.html)\n"}]},"__N_SSG":true},"page":"/cli","query":{},"buildId":"MWH9VlghDW7Swbw8zluOq","assetPrefix":"https://waynechoi.dev","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>